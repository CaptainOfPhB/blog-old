<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="CaptainOfPhB"><title>Vue 中 Computed、Watch 和 Methods 的区别 ♡ 船长の部落格</title><meta name=description content="Vue 中 Computed、Watch 和 Methods 的区别"><meta name=keywords content="Vue computed,Vue watch,Vue methods"><link rel="shortcut icon" href=/images/favicon.png><link rel=stylesheet href=/css/base.css><link rel=stylesheet href=/css/light.css><link rel=stylesheet href=/css/dark.css><link rel=stylesheet href=/css/prism-light.css><link rel=stylesheet href=/css/prism-dark.css><link rel=stylesheet href=/css/main.css></head><body><div class=main><div class=site-nav-container><div class=site-nav><a href=/>首页</a>
<a href=/posts/>归档</a>
<a href=/tags/>标签</a>
<a href=/about-me/>关于</a></div></div><div class=content><div class=single><h1 class=title>Vue 中 Computed、Watch 和 Methods 的区别</h1><div class=date>Updated&nbsp;on&nbsp;2018.07.17</div><details open class=toc><summary>Table of Contents</summary><nav id=TableOfContents><ul><li><ul><li><a href=#demo>Demo</a></li><li><a href=#computed-vs-methods>computed VS methods</a></li><li><a href=#computed-vs-watch>computed VS watch</a></li><li><a href=#computed-setter>computed setter</a></li><li><a href=#结论>结论</a></li></ul></li></ul></nav></details><div class=markdown><p>在 Vue 模板中使用表达式是十分便利的，但是这样设计的初衷是仅仅用于简单运算。在模板中使用大量的逻辑运算会使得模板变得难以维护。对于任何复杂的逻辑，都应该使用计算属性。</p><h3 id=demo>Demo</h3><p>一个最简单的翻转字符串的例子，可以将翻转之后的字符串放入一个计算属性中：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>id</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;app&#34;</span>&gt;
</span></span><span style=display:flex><span>  &lt;<span style=color:#f92672>p</span>&gt;Original message: &#34;{{ message }}&#34;&lt;/<span style=color:#f92672>p</span>&gt;
</span></span><span style=display:flex><span>  &lt;<span style=color:#f92672>p</span>&gt;Computed reversed message: &#34;{{ reversedMessage }}&#34;&lt;/<span style=color:#f92672>p</span>&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>div</span>&gt;
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>app</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Vue</span>({
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>el</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;#app&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>data</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>message</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;Hello&#39;</span>
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>computed</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 计算属性的 getter
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>reversedMessage</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>function</span> () {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// this 指向 Vue 实例
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>message</span>.<span style=color:#a6e22e>split</span>(<span style=color:#e6db74>&#39;&#39;</span>).<span style=color:#a6e22e>reverse</span>().<span style=color:#a6e22e>join</span>(<span style=color:#e6db74>&#39;&#39;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><p>你可以像绑定普通属性一样在模板中绑定计算属性。<code>reversedMessage</code> 依赖于 <code>message</code>，当 <code>message</code> 发生改变时，所有依赖 <code>reversedMessage</code> 的绑定也会更新。以声明的方式创建这种依赖关系：计算属性的 getter 函数是没有<code>副作用 (side effect)</code> 的，这使它更易于测试和理解。</p><h3 id=computed-vs-methods>computed VS methods</h3><p>你也可以使用 <code>methods</code> 实现上述的目的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>id</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;app&#34;</span>&gt;
</span></span><span style=display:flex><span>  &lt;<span style=color:#f92672>p</span>&gt;Original message: &#34;{{ message }}&#34;&lt;/<span style=color:#f92672>p</span>&gt;
</span></span><span style=display:flex><span>  &lt;<span style=color:#f92672>p</span>&gt;Computed reversed message: &#34;{{ reversedMessage() }}&#34;&lt;/<span style=color:#f92672>p</span>&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>div</span>&gt;
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>app</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Vue</span>({
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>el</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;#app&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>data</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>message</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;Hello&#39;</span>
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>methods</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 计算属性的 getter
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>reversedMessage</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>function</span> () {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// this 指向 Vue 实例
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>message</span>.<span style=color:#a6e22e>split</span>(<span style=color:#e6db74>&#39;&#39;</span>).<span style=color:#a6e22e>reverse</span>().<span style=color:#a6e22e>join</span>(<span style=color:#e6db74>&#39;&#39;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><p>两种方式的最终结果是一样的，不同之处在于<code>计算属性是基于它的依赖进行更新的</code>，如果计算属性的依赖没有更新，那么计算属性就不会更新，从缓存中取值。而使用 <code>methods</code> 时<code>每次都要重新进行计算</code>，那么当你需要进行一个计算量比较大的操作的时候，使用 <code>methods</code> 将会增加性能开销。</p><h3 id=computed-vs-watch>computed VS watch</h3><p>侦听属性 <code>watch</code> 用来观察和响应数据的变动。当你有一些数据需要<code>随着其它数据变动而变动时</code>，你应该使用<code>计算属性</code>而不是命令式的 <code>watch</code> 回调，可参照<a href=https://cn.vuejs.org/v2/guide/computed.html#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7-vs-%E4%BE%A6%E5%90%AC%E5%B1%9E%E6%80%A7 target=_blank>官网例子</a>。Vue 通过 <code>watch</code> 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。除了 <code>watch</code> 之外，还可以使用别名 <code>this.$watch</code>。</p><h3 id=computed-setter>computed setter</h3><p>我们在给计算属性提供 getter 的同时，也可以同时提供一个 setter：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#a6e22e>computed</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>fullName</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// getter
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>get</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>function</span> () {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>firstName</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39; &#39;</span> <span style=color:#f92672>+</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>lastName</span>
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:#75715e>// setter
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>set</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>function</span> (<span style=color:#a6e22e>newValue</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>names</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>newValue</span>.<span style=color:#a6e22e>split</span>(<span style=color:#e6db74>&#39; &#39;</span>)
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>firstName</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>names</span>[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>lastName</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>names</span>[<span style=color:#a6e22e>names</span>.<span style=color:#a6e22e>length</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这样做，与下面提供 <code>watch</code> 是等效的。当 <code>fullName</code> 更新时，其 setter 会被调用：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#a6e22e>computed</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>fullName</span>() {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>firstName</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39; &#39;</span> <span style=color:#f92672>+</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>lastName</span>
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>watch</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fullName</span> (<span style=color:#a6e22e>newValue</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>names</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>newValue</span>.<span style=color:#a6e22e>split</span>(<span style=color:#e6db74>&#39; &#39;</span>)
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>firstName</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>names</span>[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>lastName</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>names</span>[<span style=color:#a6e22e>names</span>.<span style=color:#a6e22e>length</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=结论>结论</h3><p>如何正确的使用这三个 Vue 为我们提供的 API 呢？</p><ul><li><code>computed</code>: 当某个数据需要随着（依赖于）另一个数据的变动而作出改变时，这时候你需要使用计算属性。</li><li><code>watch</code>: 当某个数据发生变化时，需要对这个数据的变化进行反应（进行一系列操作），这时候你需要使用侦听属性。</li><li><code>methods</code>: 与计算属性不同的是，每次读取数据时，都是计算一遍，除非你不需要缓存，否则这样做需要大量的性能开销。</li></ul><p>以上需要结合官网例子进行理解，理论结合实践最佳。</p><p>完。</p></div><div class=footer><div class=meta><span class=field><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="14" height="14" style="fill:#999;margin-right:3px"><path fill="none" d="M0 0h24v24H0z"/><path d="M7.784 14l.42-4H4V8h4.415l.525-5h2.011l-.525 5h3.989l.525-5h2.011l-.525 5H20v2h-3.784l-.42 4H20v2h-4.415l-.525 5h-2.011l.525-5H9.585l-.525 5H7.049l.525-5H4v-2h3.784zm2.011.0h3.99l.42-4h-3.99l-.42 4z"/></svg><a href=/tags/vue/>Vue</a></span></div><div class=divider></div><div class=pagination><a class=pre href=/object-freeze-and-object-seal/><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16" style="fill:#999"><path fill="none" d="M0 0h24v24H0z"/><path d="M10.828 12l4.95 4.95-1.414 1.414L8 12l6.364-6.364 1.414 1.414z"/></svg><span>Object.freeze 和 Object.seal</span></a>
<a class=next href=/data-type/><span>数据类型</span><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16" style="fill:#999"><path fill="none" d="M0 0h24v24H0z"/><path d="M13.172 12l-4.95-4.95 1.414-1.414L16 12l-6.364 6.364-1.414-1.414z"/></svg></a></div><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//daijiangtao-blog.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></div></div><script src=https://unpkg.com/prismjs@1.27.0/components/prism-core.min.js></script>
<script src=https://unpkg.com/prismjs@1.27.0/plugins/autoloader/prism-autoloader.min.js></script>
<script src=/js/main.js></script></body></html>