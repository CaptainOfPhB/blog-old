<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>船长の部落格</title>
    <link>/</link>
    <description>Recent content on 船长の部落格</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 01 Jun 2021 15:28:56 +0800</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>关于我</title>
      <link>/about-me/</link>
      <pubDate>Tue, 01 Jun 2021 15:28:56 +0800</pubDate>
      
      <guid>/about-me/</guid>
      <description>我是船长，常用的英文 ID 是 CaptainOfPhB（没改之前是 CaptainInPHW）。这个英文 ID 的意思是 Captain of Penhu Bay，即澎湖湾的老船长，当然“老”这个字就不翻译到 ID 中去了。</description>
    </item>
    
    <item>
      <title>记折腾博客（二）</title>
      <link>/2021/02/28/build-blog-2/</link>
      <pubDate>Sun, 28 Feb 2021 17:04:17 +0800</pubDate>
      
      <guid>/2021/02/28/build-blog-2/</guid>
      <description>继续上篇。
在所有的东西都配置好之后，运行 hugo 命令即可在 public 目录下构建出网站内容。静态站点需要将 public 目录作为网站的根目录进行部署。我的想法是，一份部署在国外 GitHub 上，一份部署在国内 gitee 上，这样一来除了可以做备份之外，还可以将 gitee 上的站点作为镜像，这样如果主域名访问较慢的情况下，可以切换到速度较快的国内站点进行访问。</description>
    </item>
    
    <item>
      <title>记折腾博客（一）</title>
      <link>/2021/02/25/build-blog-1/</link>
      <pubDate>Thu, 25 Feb 2021 15:55:08 +0800</pubDate>
      
      <guid>/2021/02/25/build-blog-1/</guid>
      <description>昨天折腾博客，弄好了样式等。因为我比较喜欢楷体字，所以首页的文章 list 的 summary 打算用楷体字展示。在网上搜了下楷体字的 font-family 后，在 css 文件里面这样写了：
p.content { font-family: STKaiti, KaiTi, sans-serif; } 写完部署后发现效果非常的棒。但是在手机上预览的时候发现，浏览器并没有如期展示楷体字，因为手机上貌似没有楷体字库。</description>
    </item>
    
    <item>
      <title>Unpublishing your package on npm</title>
      <link>/2021/01/25/unpublishing-your-package-on-npm/</link>
      <pubDate>Mon, 25 Jan 2021 16:09:06 +0800</pubDate>
      
      <guid>/2021/01/25/unpublishing-your-package-on-npm/</guid>
      <description>If your package is published on npm, for some reason, you want to unpublish a single version or the entire package, you can follow the steps below:</description>
    </item>
    
    <item>
      <title>TypeScript 学习笔记（三）</title>
      <link>/2020/09/20/typescript-note-3/</link>
      <pubDate>Sun, 20 Sep 2020 14:16:27 +0800</pubDate>
      
      <guid>/2020/09/20/typescript-note-3/</guid>
      <description>Literal Types  字面量（literal）：用于在代码中表示一个固定值（区别于变量，变量是可变化的） ts 中，对应的也有字面量类型。分为 String Literal Type、Number Literal Type、Boolean Literal Type 等 一般情况下，literal type 可以看做是对应的类型的子类型。比如 string literal type 可以认为是 string type 的 subtype。在这种前提下我们可以得知，literal type 是可以 assign 给对应父类型的，反之则不行（特殊情况可用 as）。以 string literal type 为例：  type TypeScript = &amp;#39;TypeScript&amp;#39;; const ts: TypeScript = &amp;#39;TypeScript&amp;#39;; const sayHello = (name: string) =&amp;gt; console.</description>
    </item>
    
    <item>
      <title>Java 学习笔记（三)</title>
      <link>/2019/06/25/java-note-3/</link>
      <pubDate>Tue, 25 Jun 2019 11:03:15 +0800</pubDate>
      
      <guid>/2019/06/25/java-note-3/</guid>
      <description>数据类型  Java 中一个 int 数据类型数据占 4 个字节（byte） 大小，32 位（bit）。最高位是符号位，剩下的 31 位存放数据 char 类型和 short 类型数据占用 2 个 byte，任何数据类型在内存中都是以二进制形式存储的 使用 man ascii 查看码表 java 中以 0 开头的数字表示 8 进制，以 0x 开头的数字表示 16 进制，0b 开头的数字表示 2 进制 java 中的数据分为原生类型和引用类型。只要能在 java 语言包中找到对应的 class 的就是引用类型，否则就是原生类型 java 中的基本类型有：     数据类型 byte int long double float char boolean void     所占空间（字节） 1 4 8 8 4 2 true/false      每个类型数据都有最大值最小值，如果超过最大最小范围， 则会发生溢出，数据会变为最初始的数值，例如:  int a = 127; System.</description>
    </item>
    
    <item>
      <title>Java 学习笔记（二)</title>
      <link>/2019/06/17/java-note-2/</link>
      <pubDate>Mon, 17 Jun 2019 10:56:14 +0800</pubDate>
      
      <guid>/2019/06/17/java-note-2/</guid>
      <description>java 是一门强类型的静态语言，编译器（compile）提供了最佳的安全保障 java 的跨平台性能良好（Windows、Linux、macOS），JVM（Java Virtual Machine）打通了不同平台和 java 之间的桥梁，这种中间层语言为 bytecode （字节码），java -&amp;gt; bytecode -&amp;gt; 机器码，一处编译，处处运行 class 类是 java 中的最小单位，一般放在与类同名的 .</description>
    </item>
    
    <item>
      <title>Java 学习笔记（一)</title>
      <link>/2019/06/16/java-note-1/</link>
      <pubDate>Sun, 16 Jun 2019 10:49:38 +0800</pubDate>
      
      <guid>/2019/06/16/java-note-1/</guid>
      <description>JRE：java runtime environment，java 运行时环境 JDK：java development kit，java 开发工具集 JRE 和 JDK 不同之处大致在于：JRE 只可以运行 java 代码，而 JDK 既可以开发，又可以运行。抽象的理解为 JDK = JRE + javac JAVA_HOME：当前 JDK 的安装路径（可能存在多个 JDK 用来切换） java 作为开发学习是完全免费的，商用收费 java v1.</description>
    </item>
    
    <item>
      <title>TypeScript 学习笔记（一）</title>
      <link>/2019/05/09/typescript-note-1/</link>
      <pubDate>Thu, 09 May 2019 16:38:15 +0800</pubDate>
      
      <guid>/2019/05/09/typescript-note-1/</guid>
      <description>ts 中的基础类型有：boolean、number、string、array、enum、元组 Tuple、any、null、undefined、never、object（除了 js 中的基础五大类型 string、number、boolean、symbol、null、undefined 之外可以用 object 类型表示） 定义数组有两种方式：&amp;lt;type&amp;gt;[] 或者使用泛型 Array&amp;lt;type&amp;gt; 元组类型表示已知数量和类型的数组，例如：let x = [number, string]。当访问越界元素时，会使用联合类型替代，例如：  let x: [string, number]; x = [&amp;#39;hello&amp;#39;, 123]; // ok x = [123, &amp;#39;hello&amp;#39;]; // error // 越界元素将是 (number | string) 类型 x[3] = &amp;#39;world&amp;#39;;  枚举 enum 默认情况下，从 0 开始为元素编号，也可手动指定成员的值。也可以根据枚举的值得到 key 的名字，例如：enum Color = { Red, Green }，则 Color[1] 的值为 Green void 表示没有任何类型，只能给 void 类型数据赋值 null 或者 undefined null 和 undefined 类型是任何类型的子类型，可以赋值给任意类型的数据。在 tsconfig 中建议开启 stricNullChecks 选项，使 null 或 undefined 只能赋值给对应的 null 或 undefined 类型断言好比类型转换，当你比 ts 更了解某个值更确切的类型时。类型断言有两种，使用尖括号或者使用 as 语法，在 tsx 中只能使用 as。例如：  let someValue: any = &amp;#39;this is a string&amp;#39; let strLength: number = (someValue as string).</description>
    </item>
    
    <item>
      <title>Git 学习笔记（一）</title>
      <link>/2019/05/08/git-note-1/</link>
      <pubDate>Wed, 08 May 2019 17:01:07 +0800</pubDate>
      
      <guid>/2019/05/08/git-note-1/</guid>
      <description>git 查看文件改动状态使用 git status git 查看改动的内容使用 git diff git 查看提交记录使用 git log 命令 HEAD 指针表示的是当前版本，上一个版本为 HEAD^，再往上就是 HEAD^^，往上一百个版本可以写作 HEAD~100 git 回退至上个版本使用 git reset &amp;ndash;hard HEAD^，若回退至指定版本，先使用 git log 查看版本的 hash，然后使用 git reset &amp;ndash;hard &amp;lt;hash_version&amp;gt; 如果回退版本后又想回到最新的版本，在不知道最新版本 hash 的情况下，使用 git reflog 查看所有 commit 的 hash，然后使用 git reset &amp;ndash;hard &amp;lt;hash_version&amp;gt; 进行回退或者前进 git VCS 分为工作区和版本库（暂存区与分支），git add 命令将改动添加进入暂存区，git commit 将改动添加到分支 工作区的文件发生了改动，想要撤销修改，可以使用 git checkout &amp;ndash; &amp;lt;file_name&amp;gt; 来撤销掉修改，注意必须要加 &amp;ndash; 符号（&amp;ndash; 与文件名之间有空格），否则 git 会认为是要切换分支 如果文件发生了改动并且已经添加到暂存区，想撤销掉暂存区的改动，使用 git reset HEAD &amp;lt;file_name&amp;gt; 命令，这样就把修改了的文件又放回工作区了，暂存区是干净的，放置到工作区后，再使用 git checkout &amp;ndash; &amp;lt;file_name&amp;gt; 将放置在工作区的文件改动撤销掉，这样两步操作就将文件的改动彻底还原了 查看工作区与版本库文件的差异可以使用 git diff HEAD &amp;ndash; &amp;lt;file_name&amp;gt;（同样，&amp;ndash; 与文件名之间有空格） 如果工作区的文件被误删除，想要恢复可以使用 git checkout &amp;ndash; &amp;lt;file_name&amp;gt;，git checkout 其实是用版本库里的版本替换工作区的版本操作，无论是工作区的修改还是删除，都可以用该命令一键还原 本地分支首次推向远程分支的时候可以使用 git push -u origin &amp;lt;branch_name&amp;gt;，其中 -u 参数是 &amp;ndash;set-upstream 的简写 切换分支使用 git checkout &amp;lt;branch_name&amp;gt;，创建并切换新分支时需要加上 -b 参数，创建新分支使用 git branch &amp;lt;branch_name&amp;gt;，查看分支 git branch 合并分支使用 git merge &amp;lt;branch_name&amp;gt;，删除使用 git branch -d &amp;lt;branch_name&amp;gt; git merge 合并分支产生冲突时，先解决冲突，再添加至暂存区，然后提交。解决冲突时，&amp;laquo;&amp;laquo;&amp;lt; HEAD 到 ===== 部分是当前分支的内容，&amp;raquo;&amp;raquo;&amp;gt; 到 ===== 部分是需要并入的分支的内容，确定好要保留好的内容后保存并退出，然后提交。提交成功后，使用 git log &amp;ndash;graph 可查看分支合并图 如果合并分支时产生冲突，想要还原回原来的状态，可以适用 git merge &amp;ndash;abort 命令 git 可以将工作区暂时的改动“存储”起来，当你不想将改动提交至暂存区时。使用 git stash 命令即可。当你想将“存储”的内容释放出来时，先使用 git stash list 查看，然后进行恢复。恢复命令有两条，使用 git stash apply &amp;lt;shash@{index}&amp;gt; （这个括号里面的内容是可选的，可以指定恢复第几个 stash 的内容，在多次 stash 时使用)，可以将存储的内容恢复至工作区，但是存储的内容并不会删除，需要删除可以使用 git stash drop &amp;lt;shash@{index}&amp;gt; 命令；另一种方式是使用 git stash pop &amp;lt;shash@{index}&amp;gt; 命令，该条命令会在恢复之后同时删除 stash 区域的内容 查看远程仓库的信息使用 git remote -v 本地分支与远程分支进行关联使用 git branch -u &amp;lt;branch_name&amp;gt; origin/&amp;lt;branch_name&amp;gt; 创建标签使用 git tag -a &amp;lt;tag_name&amp;gt; -m &amp;lt;tag_description&amp;gt; &amp;lt;commit_hash&amp;gt;，查看一个标签的内容可以使用 git show &amp;lt;tag_name&amp;gt; 推送标签可以使用 git push origin &amp;lt;tag_name&amp;gt;，一次性推送可以使用 git push origun &amp;ndash;tags 命令，删除本地标签可以使用 git tag -d &amp;lt;tag_name&amp;gt;，删除远程标签使用 git push origin :refs/tags/&amp;lt;tag_name&amp;gt;  完。</description>
    </item>
    
    <item>
      <title>React 学习笔记（一）</title>
      <link>/2019/04/16/react-note-1/</link>
      <pubDate>Tue, 16 Apr 2019 17:05:16 +0800</pubDate>
      
      <guid>/2019/04/16/react-note-1/</guid>
      <description>React 可能会把多个 setState() 调用合并成一个调用。 因为 this.props 和 this.state 可能会异步更新，所以你不要依赖他们的值来更新下一个状态  // this.</description>
    </item>
    
    <item>
      <title>我常用的 Git 命令（译）</title>
      <link>/2018/07/24/commonly-used-git-commands/</link>
      <pubDate>Tue, 24 Jul 2018 18:04:02 +0800</pubDate>
      
      <guid>/2018/07/24/commonly-used-git-commands/</guid>
      <description>本文是对 Medium 上一篇国外开发者写的博客的翻译，原文地址请点击：A Dev’s Thoughts: My Most Used Git Commands | Medium。</description>
    </item>
    
    <item>
      <title>数据类型</title>
      <link>/2018/07/19/data-type/</link>
      <pubDate>Thu, 19 Jul 2018 17:55:23 +0800</pubDate>
      
      <guid>/2018/07/19/data-type/</guid>
      <description>JavaScript 中的数据类型有：String、Number、Boolean、Null、Undefined、Object、Symbol 七大类。其中常见的有前六个。
数据分类 String、Number、Boolean、Null、Undefined 被称为基础类型数据，而 Object 类型的数据被称为引用类型数据。
数据存储 基础类型的数据直接存储于栈内存（stack）中。而 引用类型 的数据存储于堆内存（heap）中，栈内存中存储的是数据在堆内存中的引用地址，而不是真正的数据。</description>
    </item>
    
    <item>
      <title>Vue 中 Computed、Watch 和 Methods 的区别</title>
      <link>/2018/07/17/vue-computed-watch-methods/</link>
      <pubDate>Tue, 17 Jul 2018 17:38:47 +0800</pubDate>
      
      <guid>/2018/07/17/vue-computed-watch-methods/</guid>
      <description>在 Vue 模板中使用表达式是十分便利的，但是这样设计的初衷是仅仅用于简单运算。在模板中使用大量的逻辑运算会使得模板变得难以维护。对于任何复杂的逻辑，都应该使用计算属性。
Demo 一个最简单的翻转字符串的例子，可以将翻转之后的字符串放入一个计算属性中：
&amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;p&amp;gt;Original message: &amp;#34;{{ message }}&amp;#34;&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;Computed reversed message: &amp;#34;{{ reversedMessage }}&amp;#34;&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; const app = new Vue({ el: &amp;#39;#app&amp;#39;, data: { message: &amp;#39;Hello&amp;#39; }, computed: { // 计算属性的 getter  reversedMessage: function () { // this 指向 Vue 实例  return this.</description>
    </item>
    
    <item>
      <title>Object.freeze 和 Object.seal</title>
      <link>/2018/07/16/object-freeze-and-object-seal/</link>
      <pubDate>Mon, 16 Jul 2018 17:32:12 +0800</pubDate>
      
      <guid>/2018/07/16/object-freeze-and-object-seal/</guid>
      <description>Vue 的响应式是使用了 Object.defineProperty 来实现的，官方文档上注明如果想要响应式系统无法再追踪数据的变化，应该使用 Object.freeze 方法将数据“冻”起来。
 Object.freeze() 方法可以冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。也就是说，这个对象永远是不可变的。该方法返回被冻结的对象。
 parameter Obj: 需要冻结的对象。</description>
    </item>
    
    <item>
      <title>Object.defineProperty</title>
      <link>/2018/07/16/object-defineproperty/</link>
      <pubDate>Mon, 16 Jul 2018 17:20:12 +0800</pubDate>
      
      <guid>/2018/07/16/object-defineproperty/</guid>
      <description>Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。该方法允许精确添加或修改对象的属性。通过赋值来添加的普通属性会创建在属性枚举期间显示的属性（for...in 或 Object.keys 方法），这些值可以被改变，也可以被删除。这种方法允许这些额外的细节从默认值改变。默认情况下，使用 Object.defineProperty() 添加的属性值是不可变的。
语法 Object.defineProperty(obj, prop, descriptor)</description>
    </item>
    
    <item>
      <title>如何使用 Shadowsocks 获取谷歌服务</title>
      <link>/2018/06/29/use-google-by-shadowsocks/</link>
      <pubDate>Fri, 29 Jun 2018 17:00:57 +0800</pubDate>
      
      <guid>/2018/06/29/use-google-by-shadowsocks/</guid>
      <description>由于我国网络的特殊限制，很多墙外的优质资源不能够直接访问， GFW（Great FireWall，防火长城）就是互联网上那道巍峨的墙，深受程序员的痛恶。
IP 黑名单 当你打开浏览器键入 URL 访问网络资源时，域名会被解析为 IP 地址（DNS 解析，一般由网络运营商提供，或者你也可以自己指定 DNS 服务器，例如谷歌的 DNS：8.</description>
    </item>
    
    <item>
      <title>如何将域名映射至 Github 仓库</title>
      <link>/2018/06/29/domain-to-github/</link>
      <pubDate>Fri, 29 Jun 2018 16:49:00 +0800</pubDate>
      
      <guid>/2018/06/29/domain-to-github/</guid>
      <description>借助博客框架（Jekyll、Hexo、Hugo、Gatsby 等）构建并部署好自己的博客后，可以选择托管至 GitHub。进入博客所在仓库，在 Settings -&amp;gt; GitHub Pages 界面将 Source 设置为 master branch （或者其他分支）后，点击 Save 可生成博客的在线预览链接。</description>
    </item>
    
    <item>
      <title>实用的命令行工具</title>
      <link>/2018/06/28/command-line-tool/</link>
      <pubDate>Thu, 28 Jun 2018 16:36:16 +0800</pubDate>
      
      <guid>/2018/06/28/command-line-tool/</guid>
      <description>工欲善其事，必先利其器。介绍一些比较实用的命令行工具以及技巧。
asciinema Record and share your terminal sessions, an awesome terminal recording tool:</description>
    </item>
    
    <item>
      <title>优雅的 Git 提交信息</title>
      <link>/2018/06/27/git-message/</link>
      <pubDate>Wed, 27 Jun 2018 16:05:17 +0800</pubDate>
      
      <guid>/2018/06/27/git-message/</guid>
      <description>Commit change 是开发的日常操作，写好 log 不仅有助于他人 review, 还可以有效的输出 change log, 对项目的管理实际至关重要。如何写好每一个 commit message 呢？</description>
    </item>
    
    <item>
      <title>文本溢出省略</title>
      <link>/2018/06/26/text-overflow/</link>
      <pubDate>Tue, 26 Jun 2018 15:54:02 +0800</pubDate>
      
      <guid>/2018/06/26/text-overflow/</guid>
      <description>The text-overflow property in CSS deals with situations where text is clipped when it overflows the element&amp;rsquo;s box.</description>
    </item>
    
    <item>
      <title>HTTPS</title>
      <link>/2018/06/02/https/</link>
      <pubDate>Sat, 02 Jun 2018 15:35:38 +0800</pubDate>
      
      <guid>/2018/06/02/https/</guid>
      <description>HTTPS：HTTP（Hyper Text Tranfer Protocal）+ SSL（Secure Sockets Layer）/ TLS（Transport Layer Security）.</description>
    </item>
    
    <item>
      <title>CSS 常见布局</title>
      <link>/2018/03/16/css-layout/</link>
      <pubDate>Fri, 16 Mar 2018 14:55:37 +0800</pubDate>
      
      <guid>/2018/03/16/css-layout/</guid>
      <description>前端工程师的一门必修课程就是 CSS ( Cascading Style Sheet, 层叠样式表)，CSS 是一门艺术，学好 CSS 需要投入大量的时间去实践。今天我们主要聊一聊工作中常用到的 CSS 布局套路。</description>
    </item>
    
    <item>
      <title>脚本</title>
      <link>/2017/10/10/script/</link>
      <pubDate>Tue, 10 Oct 2017 11:47:01 +0800</pubDate>
      
      <guid>/2017/10/10/script/</guid>
      <description>脚本（script） 原指拍摄电影或者戏剧时，演员依据其对白演出的文件，也称之为剧本。 在编程的世界里，有时需要重复执行某些指令，这些指令或简或繁，然而反复做重复的事情是令人烦恼的。 有句话是这样说的，人类所有的发明推进都是因为人类的懒惰，因为人们懒得走路，我们发明了自行车，因为懒得骑自行车，所以我们发明了汽车， 因为汽车太慢，所以我们发明了高铁、飞机等，种种都是因为人们追求 higher、faster、stronger。 脚本亦是如此，因为程序员懒得自己敲某些重复的代码，因此我们把这些重复的常用到的指令放在一起，当我们需要的时候，直接运行这些指令即可。 参照 “脚本” 的原意，让计算机按照我们写好的指令去执行或者 “演出” 的文件，我们称之脚本文件，生成脚本文件的语言我们称之为脚本语言（Scripting language）。</description>
    </item>
    
  </channel>
</rss>
